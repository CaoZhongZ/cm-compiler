

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Tutorial 12. Kernel Deep-Dive: BitonicSort &#8212; CM 6.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/llvm-theme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '6.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Tutorial 13. Kernel Deep-Dive: RadixSort" href="cmtutorial13.html" />
    <link rel="prev" title="Tutorial 11. Kernel Programming: Register Usage" href="cmtutorial11.html" />
<style type="text/css">
  table.right { float: right; margin-left: 20px; }
  table.right td { border: 1px solid #ccc; }
</style>

  </head>
  <body>
<div class="logo">
  <a href="../index.html">
    <img src="../_static/logo.png"
         alt="Intel Logo"/></a>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="cmtutorial13.html" title="Tutorial 13. Kernel Deep-Dive: RadixSort"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="cmtutorial11.html" title="Tutorial 11. Kernel Programming: Register Usage"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">CM 6.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="cmtut.html" accesskey="U">CM (C for Media) Tutorial</a> &#187;</li> 
      </ul>
    </div>


    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <div class="section" id="tutorial-12-kernel-deep-dive-bitonicsort">
<h1>Tutorial 12. Kernel Deep-Dive: BitonicSort<a class="headerlink" href="#tutorial-12-kernel-deep-dive-bitonicsort" title="Permalink to this headline">¶</a></h1>
<p>In this tutorial, we use BitonicSort as an example to explain how to
write effective kernel code.</p>
<div class="section" id="big-picture-work-division">
<h2>Big picture: work division<a class="headerlink" href="#big-picture-work-division" title="Permalink to this headline">¶</a></h2>
<p>To avoid loading/storing excessive data from/to memory, the implementation of the bitonic sort here tries to take advantage of GRF space and do as much work as possible locally without going through memory. The algorithm is implemented using 2 kernels, cmk_bitonic_sort_256 and cmk_bitonic_merge. Given an input, the algorithm first divides the data into 256-element chunks sorted by each HW threads. Since 256 elements are loaded into GRFs, swapping elements within a chunk leverages the expressiveness of Gen register regioning. Once cm_bitonic_sort_256 is complete, 256-elements are in bitonic sequence order as depicted in Figure 1.
Cmk_bitonic_merge takes two 256-chunks and performs swapping elements based on the sorting order directions, ascending or descending.</p>
<a class="reference internal image-reference" href="../_images/bitonicsort-f1.png"><img alt="../_images/bitonicsort-f1.png" src="../_images/bitonicsort-f1.png" style="width: 800px;" /></a>
</div>
<div class="section" id="sorting-16-element-segment">
<h2>Sorting 16-element segment<a class="headerlink" href="#sorting-16-element-segment" title="Permalink to this headline">¶</a></h2>
<p>In order to explain the implementation of 256-element sort, we first start with how to sort each 16-element segment.</p>
<a class="reference internal image-reference" href="../_images/bitonicsort-f2.png"><img alt="../_images/bitonicsort-f2.png" src="../_images/bitonicsort-f2.png" style="width: 800px;" /></a>
<p>16-element sort is implemented using functions bitonic_exchange{1,2,4,8}, which compare and swap elements with the particular strides. Figure 2.a shows all the steps.</p>
<p>The following is the code for bitonic_exchange1. Figure 2.b to Figure 2.e are the corresponding illustrations.</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kr">inline</span> <span class="n">_GENX_</span> <span class="kt">void</span> <span class="nf">bitonic_exchange1</span><span class="p">(</span><span class="n">vector_ref</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">BASE_SZ</span><span class="o">&gt;</span> <span class="n">A</span><span class="p">,</span> <span class="n">vector_ref</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">BASE_SZ</span><span class="o">&gt;</span> <span class="n">B</span><span class="p">,</span>  <span class="n">vector_ref</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="n">flip</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#pragma unroll</span>
  <span class="c1">// each thread is handling 256-element chunk. Each iteration</span>
  <span class="c1">// compares and swaps two 32 elements</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">BASE_SZ</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">32</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// The first step is to select A&#39;s odd-position elements,</span>
    <span class="c1">// indicated by A.select&lt;16,2&gt;(i), which selects 16 elements</span>
    <span class="c1">// with stride 2 starting from location A[i], and copies</span>
    <span class="c1">// the selected elements to B[i] location with stride 2.</span>
    <span class="n">vector_ref</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span><span class="n">T</span> <span class="o">=</span> <span class="n">B</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="n">T</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">16</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="n">A</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">16</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="c1">// The next step selects 16 even-position elements starting</span>
    <span class="c1">// from A[i+1] and copies them over to B&#39;s odd positions</span>
    <span class="c1">// starting at B[i+1]. After the first two steps,</span>
    <span class="c1">// all even-odd pair elements are swapped.</span>
    <span class="n">T</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">16</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">A</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">16</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="c1">// The final step determines if the swapped pairs in B are</span>
    <span class="c1">// the desired order and should be preserved. If not, their values</span>
    <span class="c1">// are overwritten by their corresponding original values</span>
    <span class="c1">// (before swapping). The comparisons determine which elements</span>
    <span class="c1">// in B already meet the sorting order requirement and which are not.</span>
    <span class="c1">// Consider the first two elements of A &amp; B, B[0] and B[1] is</span>
    <span class="c1">// the swap of A[0] and A[1]. Element-wise &lt; comparison tells</span>
    <span class="c1">// that A[0] &lt; B[0], i.e., A[0] &lt; A[1]. Since the desired sorting</span>
    <span class="c1">// order is A[0] &lt; A[1], however, we already swap the two values</span>
    <span class="c1">// as we copy A to B. The XOR operation is to set the condition to</span>
    <span class="c1">// indicate which elements in original vector A have the right sorting</span>
    <span class="c1">// order. Those elements are then merged from A to B based on their</span>
    <span class="c1">// corresponding conditions. Consider B[2] and B[3] in this case.</span>
    <span class="c1">// The order already satisfies the sorting order. The flip vector</span>
    <span class="c1">// passed to this stage is [0,1,1,0,0,1,1,0]. The flip bit of B[2]</span>
    <span class="c1">// resets the condition so that the later merge operation preserves</span>
    <span class="c1">// B[2] and won&#39;t copy from A[2].</span>
    <span class="n">B</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">merge</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">T</span><span class="p">)</span> <span class="o">^</span> <span class="n">flip</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The implementation of bitonic_exchange2, 4 and 8 are similar to bitonic_exchange1. The only difference is stride distance and different flip vector. Unlike other strides, the shuffling data patterns for stride 2 cannot be expressed concisely with Gen register regioning. Take the stride 2 in stage 1 as an example, depicted in Figure 3. The first step copies A[2], A[3], A[6] and A[7] to B[0], B[1], B[4] and B[5], respectively as indicated by red arrows in Figure 3.b.</p>
<a class="reference internal image-reference" href="../_images/bitonicsort-f3.png"><img alt="../_images/bitonicsort-f3.png" src="../_images/bitonicsort-f3.png" style="width: 800px;" /></a>
<p>A straightforward CM implementation is to reshape vector A and B to 8x4 matrix and then use select() to copy elements. Reshaping vector to matrix does not generate any code. It is just a way how the compiler views the representation of the data of B. Let’s assume that vector B[0-31] reside in r10-13. format&lt;unsigned int, 8,4&gt;() intrinsic reshapes the same data into a 8x4 matrix representation as shown in Figure 4.a.</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">matrix_ref</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">MB</span> <span class="o">=</span> <span class="n">B</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">format</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span><span class="p">();</span>
<span class="n">matrix_ref</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">MA</span> <span class="o">=</span> <span class="n">A</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">format</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span><span class="p">();</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/bitonicsort-f4.png"><img alt="../_images/bitonicsort-f4.png" src="../_images/bitonicsort-f4.png" style="width: 800px;" /></a>
<p>Once both vector A and B are reshaped to 8x4 matrices, copying data from B to A is done by the following two simple CM statements.</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">MB</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">8</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="n">MA</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">8</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="n">MB</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">8</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="n">MA</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">8</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</pre></div>
</div>
<p>The source of the copy, MA.select&lt;8, 1, 2, 1&gt;(0, 2), maps to region rule well, e.g.,  r20.2&lt;8; 8, 2&gt;:ud.  However, the destination operand can have only horizontal stride, B.select&lt;8, 1, 2, 1&gt;(0, 0) cannot be mapped to Gen instruction efficiently.  The copy operation will be broken into multiple native instructions. Each mov copies only two elements, which is not SIMD efficient.</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">mov</span> <span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="n">r122</span><span class="mf">.0</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;:</span><span class="n">ud</span> <span class="n">r57</span><span class="mf">.2</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">;</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;:</span><span class="n">ud</span> <span class="p">{</span><span class="n">Align1</span><span class="p">,</span> <span class="n">Q1</span><span class="p">}</span>
<span class="n">mov</span> <span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="n">r122</span><span class="mf">.4</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;:</span><span class="n">ud</span> <span class="n">r57</span><span class="mf">.6</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">;</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;:</span><span class="n">ud</span> <span class="p">{</span><span class="n">Align1</span><span class="p">,</span> <span class="n">Q1</span><span class="p">}</span>
<span class="n">mov</span> <span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="n">r123</span><span class="mf">.0</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;:</span><span class="n">ud</span> <span class="n">r58</span><span class="mf">.2</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">;</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;:</span><span class="n">ud</span> <span class="p">{</span><span class="n">Align1</span><span class="p">,</span> <span class="n">Q1</span><span class="p">}</span>
<span class="n">mov</span> <span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="n">r123</span><span class="mf">.4</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;:</span><span class="n">ud</span> <span class="n">r58</span><span class="mf">.6</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">;</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;:</span><span class="n">ud</span> <span class="p">{</span><span class="n">Align1</span><span class="p">,</span> <span class="n">Q1</span><span class="p">}</span>
<span class="p">.</span> <span class="p">.</span> <span class="p">.</span>
</pre></div>
</div>
<p>To ameliorate the inefficiency caused by the destination restriction, we format vector A and B into matrix_ref&lt;long long,4,4&gt;. MB.select&lt;4, 1, 2, 2&gt;(0, 0) can be mapped to destination region well (stride 2) as shown in Figure 5.</p>
<a class="reference internal image-reference" href="../_images/bitonicsort-f5.png"><img alt="../_images/bitonicsort-f5.png" src="../_images/bitonicsort-f5.png" style="width: 800px;" /></a>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">MB</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="n">MA</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</pre></div>
</div>
<p>is compiled to</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">mov</span> <span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="n">r34</span><span class="mf">.0</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;:</span><span class="n">q</span> <span class="n">r41</span><span class="mf">.1</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">;</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="o">&gt;:</span><span class="n">q</span> <span class="p">{</span><span class="n">Align1</span><span class="p">,</span> <span class="n">Q1</span><span class="p">}</span>
<span class="n">mov</span> <span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="n">r36</span><span class="mf">.0</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;:</span><span class="n">q</span> <span class="n">r8</span><span class="mf">.1</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">;</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="o">&gt;:</span><span class="n">q</span> <span class="p">{</span><span class="n">Align1</span><span class="p">,</span> <span class="n">Q1</span><span class="p">}</span>
<span class="n">mov</span> <span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="n">r34</span><span class="mf">.1</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;:</span><span class="n">q</span> <span class="n">r41</span><span class="mf">.0</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">;</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="o">&gt;:</span><span class="n">q</span> <span class="p">{</span><span class="n">Align1</span><span class="p">,</span> <span class="n">Q1</span><span class="p">}</span>
<span class="n">mov</span> <span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="n">r36</span><span class="mf">.1</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;:</span><span class="n">q</span> <span class="n">r8</span><span class="mf">.0</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">;</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="o">&gt;:</span><span class="n">q</span> <span class="p">{</span><span class="n">Align1</span><span class="p">,</span> <span class="n">Q1</span><span class="p">}</span>
</pre></div>
</div>
<p>each mov copies four 64-bit data, which is 4X SIMD efficiency improvement over the straightforward implementation.</p>
<p>The following is the code for bitonic_exchange2.</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="kr">inline</span> <span class="n">_GENX_</span> <span class="kt">void</span> <span class="nf">bitonic_exchange2</span><span class="p">(</span><span class="n">vector_ref</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">BASE_SZ</span><span class="o">&gt;</span> <span class="n">A</span><span class="p">,</span> <span class="n">vector_ref</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">BASE_SZ</span><span class="o">&gt;</span> <span class="n">B</span><span class="p">,</span>  <span class="n">vector_ref</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="n">flip</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#pragma unroll</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">BASE_SZ</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">32</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">matrix_ref</span><span class="o">&lt;</span><span class="kt">long</span> <span class="kt">long</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">MB</span> <span class="o">=</span> <span class="n">B</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">format</span><span class="o">&lt;</span><span class="kt">long</span> <span class="kt">long</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="n">matrix_ref</span><span class="o">&lt;</span><span class="kt">long</span> <span class="kt">long</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">MA</span> <span class="o">=</span> <span class="n">A</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">format</span><span class="o">&lt;</span><span class="kt">long</span> <span class="kt">long</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span><span class="p">();</span>

    <span class="n">MB</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="n">MA</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">MB</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">MA</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">B</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">merge</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">B</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="o">^</span> <span class="n">flip</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="sorting-256-element-segment">
<h2>Sorting 256-element segment<a class="headerlink" href="#sorting-256-element-segment" title="Permalink to this headline">¶</a></h2>
<p>To generate efficient code, bitonic_exchange{1,2,4,8} are inlined and loops that perform compare-and-swap are unrolled. The following code is just like what gets depicted in Figure 2.a. Init_masks are the flip vectors used during exchanges.</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">const</span> <span class="n">uchar</span> <span class="n">init_mask1</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
  <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
  <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
  <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
  <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span>
<span class="p">};</span>
<span class="k">const</span> <span class="n">uchar</span> <span class="n">init_mask2</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
  <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
  <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
  <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
  <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
<span class="p">};</span>
<span class="k">const</span> <span class="n">uchar</span> <span class="n">init_mask3</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
  <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
  <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
  <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
  <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span>
<span class="p">};</span>
<span class="k">const</span> <span class="n">uchar</span> <span class="n">init_mask4</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
  <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
  <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
  <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
  <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
<span class="p">};</span>
<span class="k">const</span> <span class="n">uchar</span> <span class="n">init_mask5</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
  <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
  <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
  <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
  <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
<span class="p">};</span>
<span class="k">const</span> <span class="n">uchar</span> <span class="n">init_mask6</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
  <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
  <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
  <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
  <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span>
<span class="p">};</span>
<span class="k">const</span> <span class="n">uchar</span> <span class="n">init_mask7</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
  <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
  <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
  <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
  <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
<span class="p">};</span>
<span class="k">const</span> <span class="n">uchar</span> <span class="n">init_mask8</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
  <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
  <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
  <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
  <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
<span class="p">};</span>
<span class="k">const</span> <span class="n">uchar</span> <span class="n">init_mask9</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
  <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
  <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
  <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
  <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
<span class="p">};</span>
<span class="k">const</span> <span class="n">uchar</span> <span class="n">init_mask10</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
  <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
  <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
  <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
  <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span>
<span class="p">};</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span></span>  <span class="c1">// The first few stages are implemented with double buffers, A and B,</span>
  <span class="c1">// which reside in GRF.The output of a stride exchange step is fed</span>
  <span class="c1">// into the next exchange step as the input.cmk_read loads a 256-element</span>
  <span class="c1">// chunk starting at offset into vector A. The flip vectors basically</span>
  <span class="c1">// indicate what the desired sorting order for swapping.</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">BASE_SZ</span><span class="o">&gt;</span> <span class="n">A</span><span class="p">;</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">BASE_SZ</span><span class="o">&gt;</span> <span class="n">B</span><span class="p">;</span>
  <span class="n">cmk_read</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">BASE_SZ</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">index1</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">A</span><span class="p">);</span>

  <span class="n">vector</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="n">flip1</span><span class="p">(</span><span class="n">init_mask1</span><span class="p">);</span>

  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">short</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="n">mask</span><span class="p">;</span>
  <span class="c1">// stage 0</span>
  <span class="n">bitonic_exchange1</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">flip1</span><span class="p">);</span>
  <span class="c1">// stage 1</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="n">flip2</span><span class="p">(</span><span class="n">init_mask2</span><span class="p">);</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="n">flip3</span><span class="p">(</span><span class="n">init_mask3</span><span class="p">);</span>
  <span class="n">bitonic_exchange2</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">flip2</span><span class="p">);</span>
  <span class="n">bitonic_exchange1</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">flip3</span><span class="p">);</span>
  <span class="c1">// stage 2</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="n">flip4</span><span class="p">(</span><span class="n">init_mask4</span><span class="p">);</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="n">flip5</span><span class="p">(</span><span class="n">init_mask5</span><span class="p">);</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="n">flip6</span><span class="p">(</span><span class="n">init_mask6</span><span class="p">);</span>
  <span class="n">bitonic_exchange4</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">flip4</span><span class="p">);</span>
  <span class="n">bitonic_exchange2</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">flip5</span><span class="p">);</span>
  <span class="n">bitonic_exchange1</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">flip6</span><span class="p">);</span>
  <span class="c1">// stage 3</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="n">flip7</span><span class="p">(</span><span class="n">init_mask7</span><span class="p">);</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="n">flip8</span><span class="p">(</span><span class="n">init_mask8</span><span class="p">);</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="n">flip9</span><span class="p">(</span><span class="n">init_mask9</span><span class="p">);</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="n">flip10</span><span class="p">(</span><span class="n">init_mask10</span><span class="p">);</span>
  <span class="n">bitonic_exchange8</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">flip7</span><span class="p">);</span>
  <span class="n">bitonic_exchange4</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">flip8</span><span class="p">);</span>
  <span class="n">bitonic_exchange2</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">flip9</span><span class="p">);</span>
  <span class="n">bitonic_exchange1</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">flip10</span><span class="p">);</span>
</pre></div>
</div>
<p>However, we need to avoid bloating code size in the meantime. Hence, Stage 4 to 7 are handled in a more generic fashion. Bitonic_merge takes care of one stage that handles all recursion exchange steps. Once 7 stages are done, 256 sorted elements are written out via cmk_write().</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span>  <span class="c1">// stage 4,5,6,7 use generic bitonic_merge routine</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="n">bitonic_merge</span><span class="p">(</span><span class="n">h_pos</span><span class="o">*</span><span class="n">BASE_SZ</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

  <span class="c1">// cmk_write writes out sorted data to the output buffer.</span>
  <span class="n">cmk_write</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">BASE_SZ</span><span class="o">&gt;</span><span class="p">(</span><span class="n">index2</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">A</span><span class="p">);</span>
</pre></div>
</div>
<p>Let’s look at how bitonic_merge is implemented. A bitonic stage N has recursive steps to compare and swap elements with stride 1&lt;&lt;N, 1&lt;&lt;(N-1), …, 8, 4, 2, 1. bitonic_merge is GRF based implementation that handles stride 1 to 128 compare-and-swap steps. For stride &lt;= 128, 256 data items are kept in GRF. All compare-and-swap can all be completely done with GRF locally. Doing so avoids global synchronizations and repeating load/store 256-element chunks. Parameter m indicates the bitonic stage.  Parameter n indicates that bitonic_merge is handling stride 1&lt;&lt;n for bitonic stage m.</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="c1">// bitonic_merge for stage m has recursive steps to compare and swap</span>
<span class="c1">// elements with stride 1 &lt;&lt; m, 1 &lt;&lt; (m - 1), ... , 8, 4, 2, 1.</span>
<span class="c1">// bitonic_merge is GRF based implementation that handles stride</span>
<span class="c1">// 1 to 128 compare - and - swap steps.For stride &lt;= 128, 256 data</span>
<span class="c1">// items are kept in GRF. All compare-and-swap can all be completely</span>
<span class="c1">// done with GRF locally. Doing so avoids global synchronizations</span>
<span class="c1">// and repeating loads/stores. Parameter n indicates that bitonic_merge</span>
<span class="c1">// is handling stride 1 &lt;&lt; n for bitonic stage m.</span>
<span class="kr">inline</span> <span class="n">_GENX_</span> <span class="kt">void</span> <span class="nf">bitonic_merge</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="n">vector_ref</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">BASE_SZ</span><span class="o">&gt;</span> <span class="n">A</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// dist is the stride distance for compare-and-swap</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dist</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">n</span><span class="p">;</span>
  <span class="c1">// number of exchange passes we need</span>
  <span class="c1">// this loop handles stride distance 128 down to 16. Each iteration</span>
  <span class="c1">// the distance is halved. Due to data access patterns of stride</span>
  <span class="c1">// 8, 4, 2 and 1 are within one GRF, those stride distance are handled</span>
  <span class="c1">// by custom tailored code to take advantage of register regioning.</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">-</span><span class="mi">3</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">,</span> <span class="n">dist</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Each HW thread process 256 data elements. For a given stride</span>
    <span class="c1">// distance S, 256 elements are divided into 256/(2*S) groups.</span>
    <span class="c1">// within each group, two elements with distance S apart are</span>
    <span class="c1">// compared and swapped based on sorting direction.</span>
    <span class="c1">// This loop basically iterates through each group.</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">BASE_SZ</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="n">dist</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// Every bitonic stage, we need to maintain bitonic sorting order.</span>
      <span class="c1">// Namely, data are sorted into alternating ascending and descending</span>
      <span class="c1">// fashion. As show in Figure 9, the light blue background regions</span>
      <span class="c1">// are in ascending order, the light green background regions in</span>
      <span class="c1">// descending order. Whether data are in ascending or descending</span>
      <span class="c1">// regions depends on their position and the current bitonic stage</span>
      <span class="c1">// they are in. &quot;offset+i&quot; the position. For stage m, data of</span>
      <span class="c1">// chunks of 1&lt;&lt;(m+1) elements in all the stride steps have the</span>
      <span class="c1">// same order.</span>
      <span class="kt">bool</span> <span class="n">dir_up</span> <span class="o">=</span> <span class="p">(((</span><span class="n">offset</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
      <span class="c1">// each iteration swap 2 16-element chunks</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">dist</span><span class="o">&gt;&gt;</span><span class="mi">4</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">16</span><span class="o">&gt;</span> <span class="n">T</span> <span class="o">=</span> <span class="n">A</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">16</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span> <span class="o">*</span> <span class="mi">16</span><span class="p">);</span>
        <span class="n">vector_ref</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">16</span><span class="o">&gt;</span> <span class="n">T1</span> <span class="o">=</span> <span class="n">A</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">16</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span> <span class="o">*</span> <span class="mi">16</span><span class="p">);</span>
        <span class="n">vector_ref</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">16</span><span class="o">&gt;</span> <span class="n">T2</span> <span class="o">=</span> <span class="n">A</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">16</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span> <span class="o">*</span> <span class="mi">16</span> <span class="o">+</span> <span class="n">dist</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">dir_up</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">T1</span><span class="p">.</span><span class="n">merge</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">T2</span> <span class="o">&lt;</span> <span class="n">T1</span><span class="p">);</span>
          <span class="n">T2</span><span class="p">.</span><span class="n">merge</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">T</span> <span class="o">&gt;</span> <span class="n">T2</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
          <span class="n">T1</span><span class="p">.</span><span class="n">merge</span><span class="p">(</span><span class="n">T2</span><span class="p">,</span> <span class="n">T2</span> <span class="o">&gt;</span> <span class="n">T1</span><span class="p">);</span>
          <span class="n">T2</span><span class="p">.</span><span class="n">merge</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">T</span> <span class="o">&lt;</span> <span class="n">T2</span><span class="p">);</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// Stride 1, 2, 4, and 8 in bitonic_merge are custom tailored to</span>
  <span class="c1">// take advantage of register regioning. The implementation is</span>
  <span class="c1">// similar to bitonic_exchange{1,2,4,8}.</span>

  <span class="c1">// exchange 8</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="n">flip13</span><span class="p">(</span><span class="n">init_mask13</span><span class="p">);</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="n">flip14</span><span class="p">(</span><span class="n">init_mask14</span><span class="p">);</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">BASE_SZ</span><span class="o">&gt;</span> <span class="n">B</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">BASE_SZ</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">32</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">B</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">8</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="n">A</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">8</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">8</span><span class="p">);</span>
    <span class="n">B</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">8</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">8</span><span class="p">)</span> <span class="o">=</span> <span class="n">A</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">8</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="n">B</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">8</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">16</span><span class="p">)</span> <span class="o">=</span> <span class="n">A</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">8</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">24</span><span class="p">);</span>
    <span class="n">B</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">8</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">24</span><span class="p">)</span> <span class="o">=</span> <span class="n">A</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">8</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">16</span><span class="p">);</span>
    <span class="kt">bool</span> <span class="n">dir_up</span> <span class="o">=</span> <span class="p">(((</span><span class="n">offset</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">dir_up</span><span class="p">)</span>
      <span class="n">B</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">merge</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">B</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="o">^</span> <span class="n">flip13</span><span class="p">);</span>
    <span class="k">else</span>
      <span class="n">B</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">merge</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">B</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="o">^</span> <span class="n">flip14</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// exchange 4</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="n">flip15</span><span class="p">(</span><span class="n">init_mask15</span><span class="p">);</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="n">flip16</span><span class="p">(</span><span class="n">init_mask16</span><span class="p">);</span>
<span class="cp">#pragma unroll</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">BASE_SZ</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">32</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">matrix_ref</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="o">&gt;</span> <span class="n">MA</span> <span class="o">=</span> <span class="n">A</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">format</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="n">matrix_ref</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="o">&gt;</span> <span class="n">MB</span> <span class="o">=</span> <span class="n">B</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">format</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="n">MA</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="n">MB</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
    <span class="n">MA</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">=</span> <span class="n">MB</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="kt">bool</span> <span class="n">dir_up</span> <span class="o">=</span> <span class="p">(((</span><span class="n">offset</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">dir_up</span><span class="p">)</span>
      <span class="n">A</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">merge</span><span class="p">(</span><span class="n">B</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="p">(</span><span class="n">B</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">A</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="o">^</span> <span class="n">flip15</span><span class="p">);</span>
    <span class="k">else</span>
      <span class="n">A</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">merge</span><span class="p">(</span><span class="n">B</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="p">(</span><span class="n">B</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">A</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="o">^</span> <span class="n">flip16</span><span class="p">);</span>

  <span class="p">}</span>

  <span class="c1">// exchange 2</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="n">flip17</span><span class="p">(</span><span class="n">init_mask17</span><span class="p">);</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="n">flip18</span><span class="p">(</span><span class="n">init_mask18</span><span class="p">);</span>
<span class="cp">#pragma unroll</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">BASE_SZ</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">32</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">matrix_ref</span><span class="o">&lt;</span><span class="kt">long</span> <span class="kt">long</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">MB</span> <span class="o">=</span> <span class="n">B</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">format</span><span class="o">&lt;</span><span class="kt">long</span> <span class="kt">long</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="n">matrix_ref</span><span class="o">&lt;</span><span class="kt">long</span> <span class="kt">long</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">MA</span> <span class="o">=</span> <span class="n">A</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">format</span><span class="o">&lt;</span><span class="kt">long</span> <span class="kt">long</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span><span class="p">();</span>

    <span class="n">MB</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="n">MA</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">MB</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">MA</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="kt">bool</span> <span class="n">dir_up</span> <span class="o">=</span> <span class="p">(((</span><span class="n">offset</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">dir_up</span><span class="p">)</span>
      <span class="n">B</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">merge</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">B</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="o">^</span> <span class="n">flip17</span><span class="p">);</span>
    <span class="k">else</span>
      <span class="n">B</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">merge</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">B</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="o">^</span> <span class="n">flip18</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="c1">// exchange 1</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="n">flip19</span><span class="p">(</span><span class="n">init_mask19</span><span class="p">);</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="n">uchar</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="n">flip20</span><span class="p">(</span><span class="n">init_mask20</span><span class="p">);</span>
<span class="cp">#pragma unroll</span>
  <span class="c1">// Each iteration compares and swaps 2 32-element chunks</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">BASE_SZ</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">32</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// As aforementioned in bitonic_exchange1.</span>
    <span class="c1">// switch even and odd elements of B and put them in A.</span>
    <span class="n">vector_ref</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="n">T</span> <span class="o">=</span> <span class="n">A</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="n">T</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">16</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="n">B</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">16</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">T</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">16</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">B</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">16</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="c1">// determine whether data are in ascending or descending regions</span>
    <span class="c1">// depends on their position and the current bitonic stage</span>
    <span class="c1">// they are in. &quot;offset+i&quot; is the position. For stage m,</span>
    <span class="c1">// data of chunks of 1&lt;&lt;(m+1) elements in all the stride steps</span>
    <span class="c1">// have the same order. For instance, in stage 4, all first 32 elements</span>
    <span class="c1">// are in ascending order and the next 32 elements are in descending</span>
    <span class="c1">// order. &quot;&amp;1&quot; determines the alternating ascending and descending order.</span>
    <span class="kt">bool</span> <span class="n">dir_up</span> <span class="o">=</span> <span class="p">(((</span><span class="n">offset</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">// choose flip vector based on the direction (ascending or descending).</span>
    <span class="c1">// Compare and swap</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">dir_up</span><span class="p">)</span>
      <span class="n">A</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">merge</span><span class="p">(</span><span class="n">B</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="p">(</span><span class="n">B</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">T</span><span class="p">)</span> <span class="o">^</span> <span class="n">flip19</span><span class="p">);</span>
    <span class="k">else</span>
      <span class="n">A</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">merge</span><span class="p">(</span><span class="n">B</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="p">(</span><span class="n">B</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">T</span><span class="p">)</span> <span class="o">^</span> <span class="n">flip20</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/bitonicsort-f6.png"><img alt="../_images/bitonicsort-f6.png" src="../_images/bitonicsort-f6.png" style="width: 800px;" /></a>
</div>
<div class="section" id="sorting-more-than-256-elements">
<h2>Sorting more than 256 elements<a class="headerlink" href="#sorting-more-than-256-elements" title="Permalink to this headline">¶</a></h2>
<p>A bitonic stage sorts elements with butterfly network. For a stage K, each compare-and-swap step halves the stride distance of its prior step. The recursive step continues until stride distance 1 is complete. When stride distance is greater than 7, there is global synchronization between two steps i and i+1. Each HW thread reads processes two 256-element chunks as depicted in Figure 8. The 256-element blocks circled by light-blue dotted lines are processed by one HW threads. Global synchronization is done via enqueue from the host side. CM equeue is complete in FIFO order. Namely, one task will finish its job before the next enqueued tasks starts. The following code snippet is from the host code, BitonicSort.cpp, which is also depicted in Figure 7.</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span>  <span class="c1">// Each HW thread swap two 256-element chunks. Hence, we only need</span>
  <span class="c1">// to launch size/ (base_sort_size*2) HW threads</span>
  <span class="n">total_threads</span> <span class="o">=</span> <span class="n">size</span> <span class="o">/</span> <span class="p">(</span><span class="n">base_sort_size_</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">total_threads</span> <span class="o">&lt;</span> <span class="n">MAX_TS_WIDTH</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">width</span> <span class="o">=</span> <span class="n">total_threads</span><span class="p">;</span>
    <span class="n">height</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="p">{</span>
    <span class="n">width</span> <span class="o">=</span> <span class="n">MAX_TS_WIDTH</span><span class="p">;</span>
    <span class="n">height</span> <span class="o">=</span> <span class="n">total_threads</span> <span class="o">/</span> <span class="n">MAX_TS_WIDTH</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">CmThreadSpace</span> <span class="o">*</span><span class="n">mergeSpace</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
  <span class="n">cm_result_check</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">CreateThreadSpace</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">mergeSpace</span><span class="p">));</span>
  <span class="c1">// create merge kernel</span>
  <span class="n">CmKernel</span> <span class="o">*</span><span class="n">bitonicMerge</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
  <span class="n">cm_result_check</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">CreateKernel</span><span class="p">(</span><span class="n">program</span><span class="p">,</span>
			               <span class="s">&quot;cmk_bitonic_merge&quot;</span><span class="p">,</span>
				       <span class="n">bitonicMerge</span><span class="p">));</span>
  <span class="c1">// buffer that holds stage 7&#39;s result. All subsequent stages are writing</span>
  <span class="c1">// intermediate and final results to the same buffer so that we only need</span>
  <span class="c1">// to set this argument once</span>
  <span class="n">bitonicMerge</span><span class="o">-&gt;</span><span class="n">SetKernelArg</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">SurfaceIndex</span><span class="p">),</span> <span class="n">buf2Idx</span><span class="p">);</span>

  <span class="c1">// Creates a CmTask object.</span>
  <span class="n">CmTask</span> <span class="o">*</span><span class="n">mergeTask</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
  <span class="n">cm_result_check</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">CreateTask</span><span class="p">(</span><span class="n">mergeTask</span><span class="p">));</span>
  <span class="n">cm_result_check</span><span class="p">(</span><span class="n">mergeTask</span><span class="o">-&gt;</span><span class="n">AddKernel</span><span class="p">(</span><span class="n">bitonicMerge</span><span class="p">));</span>

  <span class="c1">// enqueue merge kernel multiple times</span>
  <span class="c1">// this loop is for stage 8 to stage LOG2_ELEMENTS.</span>
  <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">CmEvent</span> <span class="o">*</span><span class="n">mergeEvent</span><span class="p">[(</span><span class="n">LOG2_ELEMENTS</span><span class="o">-</span><span class="mi">8</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">LOG2_ELEMENTS</span><span class="o">-</span><span class="mi">7</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">];</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">LOG2_ELEMENTS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// each step halves the stride distance of its prior step.</span>
    <span class="c1">// 1&lt;&lt;j is the stride distance that the invoked step will handle.</span>
    <span class="c1">// The recursive steps continue until stride distance 1 is complete.</span>
    <span class="c1">// For stride distance less than 1&lt;&lt;8, no global synchronization</span>
    <span class="c1">// is needed, i.e., all work can be done locally within HW threads.</span>
    <span class="c1">// Hence, the invocation of j==8 cmk_bitonic_merge finishes stride 256</span>
    <span class="c1">// compare-and-swap and then performs stride 128, 64, 32, 16, 8, 4, 2, 1</span>
    <span class="c1">// locally.</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">8</span><span class="p">;</span> <span class="n">j</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">bitonicMerge</span><span class="o">-&gt;</span><span class="n">SetKernelArg</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">j</span><span class="p">);</span>
      <span class="c1">// need i to determine bitonic order direction</span>
      <span class="n">bitonicMerge</span><span class="o">-&gt;</span><span class="n">SetKernelArg</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">);</span>
      <span class="n">mergeEvent</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
      <span class="n">cm_result_check</span><span class="p">(</span><span class="n">cmd_queue</span><span class="o">-&gt;</span><span class="n">Enqueue</span><span class="p">(</span><span class="n">mergeTask</span><span class="p">,</span> <span class="n">mergeEvent</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">mergeSpace</span><span class="p">));</span>
      <span class="n">k</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/bitonicsort-f7.png"><img alt="../_images/bitonicsort-f7.png" src="../_images/bitonicsort-f7.png" style="width: 800px;" /></a>
<p>Finally, here is the cmk_bitonic_merge kernel</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">_GENX_MAIN_</span> <span class="kt">void</span> <span class="nf">cmk_bitonic_merge</span><span class="p">(</span><span class="n">SurfaceIndex</span> <span class="n">index</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// threads are mapped to a 2D space. take 2D origin (x,y) and unfold them</span>
  <span class="c1">// to get the thread position in 1D space. use tid read the data chunks</span>
  <span class="c1">// the thread needs to read from the index surface</span>
  <span class="n">uint</span> <span class="n">tid</span> <span class="o">=</span> <span class="n">get_thread_origin_x</span><span class="p">()</span> <span class="o">+</span> <span class="n">get_thread_origin_y</span><span class="p">()</span><span class="o">*</span><span class="n">MAX_TS_WIDTH</span><span class="p">;</span>
  <span class="c1">// which 2-to-(n+1) segment the thread needs to work on</span>
  <span class="c1">// each thread swap two 256-element blocks.</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">seg</span> <span class="o">=</span> <span class="n">tid</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">8</span><span class="p">));</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">seg_sz</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
  <span class="c1">// calculate the offset of the data this HW is reading. seg*seg_sz is</span>
  <span class="c1">// the starting address of the segment the thread is in. As aforementioned,</span>
  <span class="c1">// each segment needs 1&lt;&lt;(n-8) threads. tid%(1&lt;&lt;(n-8) which 256-element</span>
  <span class="c1">// chunk within the segment this HW thread is processing.</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">seg</span> <span class="o">*</span> <span class="n">seg_sz</span> <span class="o">+</span> <span class="p">(</span><span class="n">tid</span> <span class="o">%</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">8</span><span class="p">))</span><span class="o">*</span><span class="n">BASE_SZ</span><span class="p">));</span>
  <span class="c1">// stride distance</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dist</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">n</span><span class="p">;</span>
  <span class="c1">// determine whether data are in ascending or descending regions depends on</span>
  <span class="c1">// their position and the current bitonic stage they are in.</span>
  <span class="c1">// &quot;offset&quot; is the position. For stage m, data of chunks of 1&lt;&lt;(m+1)</span>
  <span class="c1">// elements in all the stride steps have the same order.</span>
  <span class="c1">// &quot;&amp;1&quot; determines the alternating ascending and descending order.</span>
  <span class="kt">bool</span> <span class="n">dir_up</span> <span class="o">=</span> <span class="p">((</span><span class="n">offset</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
  <span class="c1">// read oword 32 elements each time</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">BASE_SZ</span><span class="o">&gt;</span> <span class="n">A</span><span class="p">;</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">BASE_SZ</span><span class="o">&gt;</span> <span class="n">B</span><span class="p">;</span>

<span class="cp">#pragma unroll</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">BASE_SZ</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">32</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// byte offset</span>
    <span class="n">cmk_read</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="p">(</span><span class="n">offset</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">,</span> <span class="n">A</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
    <span class="n">cmk_read</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="p">(</span><span class="n">offset</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="n">dist</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">,</span> <span class="n">B</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
    <span class="c1">// compare 32 elements at a time and merge the result based on</span>
    <span class="c1">// the sorting direction</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="n">T</span> <span class="o">=</span> <span class="n">A</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">dir_up</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">A</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">merge</span><span class="p">(</span><span class="n">B</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">B</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">A</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
      <span class="n">B</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">merge</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">T</span> <span class="o">&gt;</span> <span class="n">B</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
      <span class="n">A</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">merge</span><span class="p">(</span><span class="n">B</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">B</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">A</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
      <span class="n">B</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">merge</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">T</span> <span class="o">&lt;</span> <span class="n">B</span><span class="p">.</span><span class="n">select</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="c1">// Once stride distance 256 is reached, all subsequent recursive steps</span>
  <span class="c1">// (n = 7, 6, ..., 1) can be resolved locally as all data reside</span>
  <span class="c1">// in vector A and B. Thus, reduce the overhead of returning back to</span>
  <span class="c1">// the host side and relaunch tasks. Also writing data back to</span>
  <span class="c1">// memory and reading it back is avoided. bitonic_merge is</span>
  <span class="c1">// the routine explained earlier.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Vector A has 256 elements. Call bitonic_merge to process</span>
    <span class="c1">// the remaining stride distance for A. A&#39;s sorted result is</span>
    <span class="c1">// immediately written out to memory. Doing so avoids spilling</span>
    <span class="c1">// because A&#39;s lifetime ends without interfering with</span>
    <span class="c1">// bitonic_merge(... B ...)</span>
    <span class="n">bitonic_merge</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>
    <span class="n">cmk_write</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">BASE_SZ</span><span class="o">&gt;</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">offset</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">,</span> <span class="n">A</span><span class="p">);</span>
    <span class="n">bitonic_merge</span><span class="p">(</span><span class="n">offset</span> <span class="o">+</span> <span class="n">dist</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>
    <span class="n">cmk_write</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">BASE_SZ</span><span class="o">&gt;</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="p">(</span><span class="n">offset</span> <span class="o">+</span> <span class="n">dist</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">,</span> <span class="n">B</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="p">{</span>
    <span class="n">cmk_write</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">BASE_SZ</span><span class="o">&gt;</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">offset</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">,</span> <span class="n">A</span><span class="p">);</span>
    <span class="n">cmk_write</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">BASE_SZ</span><span class="o">&gt;</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="p">(</span><span class="n">offset</span> <span class="o">+</span> <span class="n">dist</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">,</span> <span class="n">B</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/bitonicsort-f8.png"><img alt="../_images/bitonicsort-f8.png" src="../_images/bitonicsort-f8.png" style="width: 800px;" /></a>
</div>
</div>


          </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="cmtutorial13.html" title="Tutorial 13. Kernel Deep-Dive: RadixSort"
             >next</a> |</li>
        <li class="right" >
          <a href="cmtutorial11.html" title="Tutorial 11. Kernel Programming: Register Usage"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">CM 6.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="cmtut.html" >CM (C for Media) Tutorial</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2009-2016, Intel Corporation. All rights reserved.
      Last updated on Fri Feb 22 15:24:15 2019 -0800.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.1.
    </div>
  </body>
</html>